集合

集合类概述
为什么出现集合类
面向对象语言对事物的体现都是以对象的形式 所以为了方便对多个对象的操作 Java就提供了集合类
数组和集合类同是容器 有何不同
数组虽然也可以存储对象 但长度是固定的 集合长度是可变的 数组中可以存储基本数据类型 集合只能存储对象
集合类的特点
集合只用于存储对象 集合长度是可变的 集合可以存储不同类型的对象

Collection 接口概述
Collection接口概述
Collection 层次结构中的根接口 Collection 表示一组对象 这些对象也称为collection 的元素 一些collection允许有重复的元素 而另一些则不允许 一些collection是有序的 而另一些则是无序的

Collection接口成员方法
boolean add(E e)
boolean remove(Object o)
void clear()
boolean contains(Object o)
boolean isEmpty()
int size()

注意:collectionXxx.java使用了未经检查或不安全的操作.
注意:要了解详细信息,请使用 -Xlint:unchecked重新编译.
java编译器认为该程序存在安全隐患
温馨提示:这不是编译失败,所以先不用理会,等学了泛型你就知道了


Collection接口成员方法
boolean addAll(Collection c)
boolean removeAll(Collection c)
boolean containsAll(Collection c)
boolean retainAll(Collection c)

Collection接口成员方法
Object[] toArray() 把集合转成数组 可以实现集合的遍历
Iterator iterator() 迭代器 集合的专用遍历方式

Iterator 接口概述
Iterator 接口概述
对collection进行迭代的迭代器
依赖于集合而存在

Iterator接口成员方法
boolean hasNext()
E next()

Iterator 接口的使用和原理讲解
Iterator 接口的使用讲解
Iterator 接口的原理讲解
为什么不定义成一个类 而是一个接口
看源码是如何实现的

1：迭代器接口使用的时候，使用for循环还是while循环
2:注意事项:迭代器在使用的时候，有人为了方便，如下使用就会有问题
	System.out.println(((Student)it.next()).getName()+”---”+((Student)it.next()).getAge());

Collection案例
存储字符串并遍历
存储自定义对象并遍历 Student(name,age)

注意事项:迭代器在使用的时候，有人为了方便，如下使用就会有问题
	System.out.println(((Student)it.next()).getName()+”---”+((Student)it.next()).getAge());

List接口概述
List接口概述
有序的collection(也称为序列) 此接口的用户可以对列表中每个元素的插入位置进行精确地控制 用户可以根据元素的整数索引(在列表中的位置) 访问元素 并搜索列表中的元素
与set不同 列表通常允许重复的元素
List案例
存储字符串并遍历
存储自定义对象并遍历

List接口成员方法
void add(int index, E element)
E remove(int index)
E get(int index)
E set(int index, E element)
ListIterator listIterator()

ListIterator接口的成员方法
boolean hasPrevious()
E previous()

ConcurrentModificationException 
现象
原因
解决方案

常见数据结构
栈
队列
数组
链表
树
哈希表

面试前要知道的一个知识点：
	常见的数据结构的优缺点

ArrayList类概述及使用
ArrayList类概述
底层数据结构是数组 查询快 增删慢
线程不安全 效率高
ArrayList案例
存储字符串并遍历
存储自定义对象并遍历

Vector类概述及使用
Vector类概述
底层数据结构是数据 查询快 增删慢
线程安全 效率低
Vector 类特有功能
public void addElement(E obj)
public E elementAt(int index)
public Enumeration elements()
Vector案例
存储字符串并遍历
存储自定义对象并遍历

LinkedList类概述及使用
LinkedList类概述
底层数据结构是链表 查询慢 增删快
线程不安全 效率高
LinkedList类特有功能
public void addFirst(E e)及addLast(E e)
public getFirst()及getLast()
public removeFirst()及public E removeLast()
LinkedList案例
存储字符串并遍历
存储自定义对象并遍历

List集合练习
ArrayList
去除集合中字符串的重复值(字符串的内容相同)
去除集体合中自定义对象的重复值(对象的成员变量值都相同)
LinkedList
请用LinkedList模拟栈数据结构的集合 并测试

泛型概述及使用
JDK1.5以后出现的机制
泛型出现的原因
泛型出现的好处
泛型的书写格式
把前面的集合代码用泛型号改进

1：泛型是一种特殊的类型，它把指定类型的工作推迟到客户端代码声明并实例化类或方法的时候进行。
   也被称为参数化类型，可以把类型当作参数一样传递过来，在传递过来之前我不明确，但是在使用的时候我就用明确了。
2：泛型的好处
A:提高了程序的安全性
B:将运行期遇到的问题转移到了编译期
C:省去了类型强转的麻烦

泛型由来
为什么会有泛型呢
通过案例引入 
早期的Object类型可以接收任意的对象类型 但是在实际的使用中 会有类型转换的问题 也就存在这隐患 所以Java提供了泛型号来解决这个安全问题

泛型应用
泛型类
把泛型定义在类上
格式 public class 类名<泛型类型1, ...>
注意 泛型类型必须是引用类型
泛型方法
把泛型定义在方法上
格式 public <泛型类型> 返回类型 方法名(泛型类型)
泛型接口
把泛型定义在接口上
格式 public interface 接口名<泛型类型1 ...>

泛型高级(通配符)
泛型通配符<?>
任意类型 如果没有明确 那么就是Object以及任意的Java类了
? extends E 向下限定 E及其子类
? super E 向上限定 E及其父类

class Animal {}
class Dog extends Animal {}
class Cat extends Animal {}
public class CollectionDemo {
public static void main(String[] args) {
Collection<?> c1 = new ArrayList<Animal>();
Collection<?> c2 = new ArrayList<Dog>();
Collection<?> c3 = new ArrayList<Cat>();
Collection<?> c4 = new ArrayList<Object>();

Collection<? extends Animal> c5 = new ArrayList<Animal>();
Collection<? extends Animal> c6 = new ArrayList<Dog>();
Collection<? extends Animal> c7 = new ArrayList<Cat>();
// Collection<? extends Animal> c8 = new ArrayList<Object>();

Collection<? super Animal> c9 = new ArrayList<Animal>();
// Collection<? super Animal> c10 = new ArrayList<Dog>();
// Collection<? super Animal> c11 = new ArrayList<Cat>();
Collection<? super Animal> c12 = new ArrayList<Object>();

增强for概述及使用
增强for概述 简化数组和Collection集合的遍历
格式 for(元素数据类型 变量:数组或者Collection集合){使用变量即可 该变量就是元素}
好处 简化遍历
注意事项 增强for的目标要判断是否为null
把前面的集合代码的遍历用增强for改进

1:public interface Iterable<T> 实现这个接口允许对象成为 "foreach" 语句的目标。 

静态导入概述及使用
静态导入概述
格式 import static 包名 ... 类名.方法名;
可以直接导入到方法的级别
注意事项
方法必须是静态的
如果有多个同名的静态方法 容易不知道使用谁 这个时候要使用 必须加前缀 由此可见 意义不大 所以一般不用 但是要能看懂

可变参数概述及使用
可变参数概述 定义方法的时候不知道该定义多少参数
格式
修饰符 返回值类型 方法名(数据类型 ... 变量名){}
注意
这里的变量其实是一个数组
如果一个方法有可变参数 并且有多个参数 那么 可变参数肯定是最后一个
Arrays工具类中的一个方法 public static <T> List<T> asList(T ... a)

List集合练习
集合的嵌套遍历
获取10个1-20之间的随机数 要求不能重复
键盘录入多个数据 以0结束 要求在控制台输出这多个数据中的最大值

Set接口概述
Set接口概述 一个不包含重复元素的collection
Set案例
存储字符串并遍历
存储自定义对象并遍历

HashSet类概述
HashSet类概述
不保证set的迭代顺序
特别是它不保证该顺序恒久不变
HashSet如何保证元素唯一性
底层数据结构是哈希表(元素是链表的数组)
哈希表依赖于哈希存储
添加功能底层依赖两个方法 int hashCode()  boolean equals(Object obj)

LinkedHashSet类概述
LinkedHashSet类概述
元素有序唯一
由链表保证元素有序
由哈希表保证元素唯一

TreeSet类概述
TreeSet类概述
使用元素的自然顺序对元素进行排序
或者根据创建set时提供的Comparator进行排序
具体取决于使用的构造方法
TreeSet是如何保证元素的排序和唯一性的
底层数据结构是红黑树(红黑树是一种自平衡的二叉树)

用TreeSet存储Integer类型数据讲解排序和唯一。
	20,18,23,22,17,24,19,18,24

Set集合练习
HashSet集合存储自定义对象并遍历 如果对象的成员变量值相同即为同一个对象
TreeSet集合存储自定义对象并遍历
如果对象的成员变量值相同即为同一个对象
按照年龄进行从大到小进行排序
编写一个程序 获取10个1至20的随机数 要求随机数不能重复
键盘录入5个学生信息(姓名 语文成绩 数学成绩 英语成绩) 按照总分从高到低输出到控制台

// 创建集合对象
HashSet<Integer> hs = new HashSet<Integer>();
// 创建随机数对象
Random r = new Random();

while (hs.size() < 10) {
hs.add(r.nextInt(20) + 1);
}

System.out.println("hs:" + hs);

Collection集合总结
Collection
List ArrayList Vector LinkedList
Set HashSet TreeSet

Map接口概述
Map接口概述
将键映射到值的对象
一个映射不能包含重复的键
每个键最多只能映射到一个值
Map接口和Collection接口的不同
Map是双列的 Collection是单列的
Map的键唯一 Collection的子体系Set是唯一的
Map集合的数据结构值针对键有效 跟值无关 Collection集合的数据结构是针对元素有效

Map接口成员方法
V put(K key, V value)
V remove(Object key)
void clear()
boolean containsKey(Object key)
boolean containsValue(Object value)
boolean isEmpty()
int size()

Map接口成员方法
V get(Object key)
Set<K> keySet()
Collection<V> values()
Set<Map.Entry<K, V>> entrySet()

Map集合遍历
根据键找值
获取所有键的集合
遍历键的集合 获取到每一个键
根据键找值
根据键值对对象找键和值
获取所有键值对对象的集合
遍历键值对对象的集合 获取到每一个键值对对象
根据键盘值班对对象找键和值

通过存储字符串讲解遍历

HashMap类概述
HashMap类概述 键是哈希表结构 可以保证键的唯一性
HashMap案例
HashMap<String, String>
HashMap<Integer, String>
HashMap<String, Student>
HashMap<Student, String>

LinkedHashMap 类概述
Map 接口的哈希表和链接列表实现 具有可预知的迭代顺序

TreeMap 类概述
TreeMap 类概述 键是红黑树结构 可以保证键的排序和唯一性
TreeMap 案例
HashMap<String, String>
HashMap<Student, String>

Map集合案例
"aababcabcdabcde",获取字符串中每一个字母出现的次数要求结果:a(5)b(4)c(3)d(2)e(1)
集合的嵌套遍历
HashMap嵌套HashMap
HashMap嵌套ArrayList
ArrayList嵌套HashMap

HashMap集合嵌套ArrayList集合并遍历。
 需求：
 		假设HashMap集合的元素是ArrayList。有3个。
 		每一个ArrayList集合的值是字符串。
 		元素我已经完成，请遍历。
 结果：
		 三国演义
		 	吕布
		 	周瑜
		 笑傲江湖
		 	令狐冲
		 	林平之
		 神雕侠侣
		 	郭靖
		 	杨过  

ArrayList集合嵌套HashMap集合并遍历。
  需求：
  	假设ArrayList集合的元素是HashMap。有3个。
  	每一个HashMap集合的键和值都是字符串。
  	元素我已经完成，请遍历。
  结果：
	 周瑜---小乔
	 吕布---貂蝉

	 郭靖---黄蓉
	 杨过---小龙女

	 令狐冲---任盈盈
	 林平之---岳灵珊

面试题
HashMap和Hashtable的区别
ListSetMap等接口是否都继承子Map接口

Collections类概述和成员方法 针对集合操作的工具类
Collections成员方法
public static <T> void sort(List<T> list)
public static <T> int binarySearch(List<?> list, T key)
public static <T> T max(Collection<?> coll)
public static void reverse(List<?> list)
public static void shuffle(List<?> list)

Collections成员方法的使用
模拟斗地主洗牌和发牌
模拟斗地主洗牌和发牌
对牌进行排序
并同时使用Map List Set 等集合 可以知道什么时候使用哪种集合

集合总结
集合
Collection
List
Set

Map