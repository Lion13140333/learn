继承
多态
抽象类
接口
包和导包
权限修饰符
内部类

继承概述
多个类中存在相同属性和行为时 将这些内容抽取到单独一个类中 那么多个类无需再定义这些属性和行为 只要继承那个类即可
通过extends关键字可以实现类与类的继承 class 子类名 extends 父类名称 {}
单独的这个类称为父类 基类或者超类 多个类可以称为子类或者派生类
有了继承以后 我们定义一个类的时候 可以在一个已经存在的类的基础上 还可以定义自己的新成员


1:通过学生类和老师类中都有相同的成员变量和成员方法来说明代码的重复度很高，
  而且，可能还有许多类似的类，比如：工人类，军人类等。
  这样写代码的代码量非常大，而且将来维护起来就比较麻烦。
  所以，我们就思考：能不能把相同的成员定义到同一个类中，让这个多个类和这个类产生一个关系，
  这多个类就具备了这个独立的类的成员。该有多好呢?请问可以吗?当然可以了，这就是Java中提供的继承技术。

2:改进代码，把相同的成员抽取到一个类中，名字好起。
  但是，多个类如何和这个类产生一个关系呢?
  引出继承格式。

3:顺便说一下，这一个类的叫法(父类，基类，超类)。这多个类的叫法(子类,派生类)。

继承的案例和继承的好处
通过一个具体案例来演示代码
案例1 学生类和老师 定义两个功能(吃饭 睡觉)
案例2 加入人类后改进

继承的好处
提高了代码的复用性 多个类相同的成员可以放到同一个类中
提高了代码的维护性 如果功能的代码需要修改 修改一处即可
让类与类之间产生了关系 是多态的前提 其实这也是继承的一个弊端：类的耦合性很强

1:设计原则：高内聚低耦合。
	简单的理解：
	内聚就是自己完成某件事情的能力。
	耦合就是类与类之间的关系。
我们在设计的时候原则是：自己能完成的就不麻烦别人，这样将来别人产生了修改，就对我的影响较小。
由此可见：在开发中使用继承其实是在使用一把双刃剑。今天我们还是以继承的好处来使用，因为继承还有很多其他的特性。


Java中继承的特点
Java只支持单继承 不支持多继承
一个类只能有一个父类 不可以有多个父类
class SubDemo extends Demo{}  // 可以
class SubDemo extends Demo1,Demo2... // 错误 不可以
Java支持多层继承(继承体系)
class A{}
class B extends A{}
class C extends B{}

1:通过子类，同时继承父亲类，目前来演示发现不可以。
2:通过子类，继承父亲，父亲继承爷爷演示。


Java中继承的注意事项
子类只能继承父类所有非私有的成员(成员方法和成员变量) 其实这也体现了继承的另一个弊端：打破了封装性
子类不能继承父类的构造方法 但是可以通过super(后面讲)关键字去访问父类构造方法
不要为了部分功能而去继承
我们到底在什么时候使用继承 继承中类之间体现的是 "is a"的关系

1:在父类中定义私有方法，然后来一个子类，然后在测试类创建子类对象调用发现使用不了。
其实通过父类也使用不了，不过，在父类中是可以使用的。
2:我们发现两个类有部分代码相同，我们就让这两个类产生一个继承关系，这是不对的，代码演示。
3:我们要想知道什么时候使用继承，就必须知道继承间类的关系：
	举例：水果和苹果，苹果是一种水果。
                  学生和人，学生是人的一种。

继承中成员变量的关系
案例演示 子父类中同名和不同名的成员变量
结论
在子类方法中访问一个变量
首先在子类局部范围找
然后在子类成员范围找
最后在父类成员范围找(肯定不能访问到父类局部范围)
如果还是没有就报错(不考虑父类的父类...)

1:在父类中定义一个成员变量
2:在子类中定义一个成员变量和父类中成员变量名称不同，然后再在子类中定义一个方法去访问变量，发现变量名不同，访问非常简单
3:在子类中再定义一个成员变量，和父类中的成员变量名称一致，然后继续访问。发现访问的是子类的成员变量。
4:如果我要访问父类的成员变量该怎么办呢?通过回想this来引入super关键字

super 关键字
super的用法和this很像
this代表本类对应的引用
super代表父类存储空间的标识(可以理解为父类引用)
用法(this和super均可如下使用)
访问成员变量 this成员变量 super成员变量
访问构造方法(子父类的构造方法问题讲)
this(...) super(...)
访问成员方法(子父类的成员方法问题讲)
this成员方法() super成员方法()


1:看程序写结果
	class Test
	{
		private static int x =  10;

		public void show(int x)  
		{
			x++;
			System.out.println(x);
		} 

		public static void main(String[] args)
		{
			int x = 20;	
			Test t = new Test();
			t.show(x);
		}
	} 

继承中构造方法的关系
子类中所有的构造方法默认都会访问父类中空参数的构造方法
为什么呢
因为子类会继承父类中的数据 可能还会使用父类的数据 所以 子类初始化之前 一定要先完成父类数据的初始化
每一个构造方法的第一条语句默认都是 super()

1:类中所有的构造方法默认都会访问父类中空参数的构造方法。通过案例演示
2:为什么会这个样子呢?
	因为子类会继承父类中的数据，可能还会使用父类的数据。
	所以，子类初始化之前，一定要先完成父类数据的初始化。
	为了实现这个效果，在子类构造的第一条语句上默认有一个：super();然后加上看效果	
3:在这里简单的提一句，Object类。否则有人就会针对父类的构造方法有疑问。Object在没有父类了。


如何父类中没有构造方法 该怎么办
子类通过super去显示调用父类其他的带参的构造方法
子类通过this去调用本类的其他构造方法 本类其他构造也必须首先访问了父类构造
一定要注意
super(...)或者this(...)必须出现在第一条语句上
否则 就会有父类数据的多次初始化
看程序写结果

1:看程序写结果
	class Fu{
		public int num = 10;
		public Fu(){
			System.out.println("fu");
		}
	}
	class Zi extends Fu{
		public int num = 20;
		public Zi(){
			System.out.println("zi");
		}
		public void show(){
			int num = 30;
			System.out.println(num);
			System.out.println(this.num);
			System.out.println(super.num);
		}
	}
	class Test {
		public static void main(String[] args) {
			Zi z = new Zi();
			z.show();
		}
	}
2:面试题
	class Fu {
		static {
			System.out.println("静态代码块Fu");
		}

		{
			System.out.println("构造代码块Fu");
		}

		public Fu() {
			System.out.println("构造方法Fu");
		}
	}

	class Zi extends Fu {
		static {
			System.out.println("静态代码块Zi");
		}

		{
			System.out.println("构造代码块Zi");
		}

		public Zi() {
			System.out.println("构造方法Zi");
		}
	}

	Zi z = new Zi(); 请执行结果。

	A:静态随着类的加载而加载。
	B:静态代码块 -- 构造代码块 -- 构造方法的执行流程
		静态代码块 -- 构造代码块 -- 构造方法
	C:只要有子父关系，肯定先初始化父亲的数据，然后初始化子类的数据。

	结果：
		静态代码块Fu
		静态代码块Zi
		构造代码块Fu
		构造方法Fu
		构造代码块Zi
		构造方法Zi

3:面试题
	class X {
		Y b = new Y();
		X() {
			System.out.print("X");
		}
	}
	class Y {
		Y() {
			System.out.print("Y");
		}
	}
	public class Z extends X {
		Y y = new Y();
		Z() {
			System.out.print("Z");
		}
		public static void main(String[] args) {
			new Z(); 
		}
	}

	铺垫的小知识：
	第一个：成员变量有基本类型和引用类型的。
	class Demo {
		//基本类型
		int x = 10;
		//引用类型
		Student s = new Student();
	}
	
	第二个：类的初始化过程
		加载class文件
		堆中开辟空间
		变量的默认初始化
		变量的显示初始化
		构造代码块初始化
		构造方法初始化

	第三个：遇到extends，就要知道，先初始化父类数据，然后初始化子类数据。
		分层初始化。
		super在这里仅仅表示要先初始化父类数据。

案例演示 子父类中同名和不同名的成员方法
结论 通过子类对象去访问一个方法
首先在子类中找
然后在父类中找
如果还是没有就报错(不考虑父类的父类)

1:在父类中定义一个成员方法
2:在子类中定义一个成员方法和父类中成员方法名称不同，然后在测试类中通过子类对象去访问方法，发现方法名不同，访问非常简单
3:在子类中再定义一个成员方法，和父类中的成员方法名称一致，然后继续访问。发现访问的是子类的成员方法。
4:如果我要访问父类的成员方法该怎么办呢?回想刚才提过的super关键字

方法重写概述
子类中出现了和父类中一模一样的方法声明 也被称为方法覆盖 方法复写
使用特点
如果方法名不同 就调用对应的方法
如果方法名相同 最终使用的是子类自己的
方法重写的应用
当子类需要父类的功能 而功能主体子类有自己特有内容时 可以重写父类中的方法 这样 即沿袭了父类的功能 又定义了子类特有的内容

1:刚才讲过的子类中出现了父类中一模一样的方法，这种现象其实在Java中被称为方法重写
2:方法重写的应用：
	举例：手机类和新式手机类。(加入好听的彩铃功能，基本功能由手机提供)

方法重写的注意事项
父类中私有方法不能被重写
子类重写父类方法时 访问权限不能更低
父类静态方法 子类也必须通过静态方法进行重写(其实这个算不上方法重写 但是现象确实如此 至于为什么算不上方法重写 多态中会讲解)

面试题
方法重写和方法重载的区别 方法重载能改变返回值类型吗
Overload
Override

this关键字和super关键字分别代表什么 以及他们各自的使用场景和作用

继承练习
学生案例和老师案例讲解
使用继承前
使用继承后 父类中成员private修饰 子类如何访问
猫狗案例讲解 分析和实现

final关键字
final关键字是最终的意思 可以修饰类 成员变量 成员方法
修饰类 类不能被继承
修饰变量 变量就变成了常量 只能被赋值一次
修饰方法 方法不能被重写

1:通过子类重写父类方法，来说明父类不能被人动的方法，也别动了。为了强制不能动，Java就提高了final关键字

final关键字面试题
final修饰局部变量
在方法内容 该变量不可以被改变
在方法声明上 分别演示基本类型和引用类型作为参数的情况  基本类型 是值不能被改变  引用类型 是地址值不能被改变
final修饰变量的初始化时机 在对象构造完毕前即可

多态概述
某一个事物 在不同时刻表现出来的不同状态
举例
猫可以是猫的类型 猎 m = new 猫();
同时猫也是动物的一种 也可以把猫称为动物 动物 d = new 猫();
在举一个例子 水在不同时刻的状态
多态前提和体现
有继承关系
有方法重写
有父类引用指向子类对象

1:通过猫这个小动物，说猫可以被称为猫，也可以被称为动物。在不同时刻，猫表现出的不同状态，来说明多态。

多态案例及成员访问特点
多态案例 按照前提写一个多态的案例
成员访问特点
成员变量 编译看左边 运行看左边
成员方法 编译看左边 运行看右边
静态方法 编译看左边 运行看左边 所以前面我说静态方法不能算方法的重写

多态的好处和弊端
多态的好外
提高了程序的维护性(由继承保证)
提高了程序的扩展性(由多态保证)
多态的弊端
不能访问子类特有功能
那么我们如何才能访问子类的特有功能呢 多态中的转型

1:通过一个案例演示多态的好处，提高程序的扩展性。

多态中的转型问题
向上转型 从子到父 父类引用指向子类对象
向下转型 从父到子 父类引用转为子类对象
多态成员访问及转型的理解 孔子装爹案例

1:案例演示时，子类提供一个父类没有功能。案例演示完毕后，画图解释。
	动物和猫，狗案例
2:多态成员访问及转型的理解。孔子装爹案例
3:判断下面的赋值哪些是正确的：最后，总结从右，往左看，是否能够读通。如果可以，就正确，否则就错误。
class Animal{}
class Dog extends Animal{}
class Cat extends Animal{}
以及
Animal p0 = new Animal();
Dog p1 = new Dog ();
Cat p2 = new Cat ();
Animal p3 = new Dog ();
Animal p4 = new Cat ();

p0 = p1;
p1 = p2;
p1 = (Dog)p3;
p2 = (Cat)p4;

多态练习
猫狗案例练习多态版
不同地方饮食文化不同的案例
Person eat()
SouthPerson eat()
NorthPerson eat()

1:人要吃饭
2:南方人吃炒菜和米饭
3:北方人吃烩菜和馒头

先基本的调用，后多态调用。

抽象类概述
回想前面我们的猫狗案例，提取出了一个动物类。并且我们在前面也创建过了动物对象，其实这是不对的。
    为什么呢?因为，我说动物，你知道我说的是什么动物吗?只有看到了具体的动物，你才知道，这是什么动物。 所以说，动物本身并不是一个具体的事物，而是一个抽象的事物。只有真正的猫，狗才是具体的动物。同理，我们也可以推想，不同的动物吃的东西应该是不一样的，所以，我们不应该在动物类中给出具体体现，而是应该给出一个声明即可。

回想前面我们的猫狗案例，提取出了一个动物类。并且我们在前面也创建过了动物对象，其实这是不对的。
    为什么呢?因为，我说动物，你知道我说的是什么动物吗?只有看到了具体的动物，你才知道，这是什么动物。 所以说，动物本身并不是一个具体的事物，而是一个抽象的事物。只有真正的猫，狗才是具体的动物。同理，我们也可以推想，不同的动物吃的东西应该是不一样的，所以，我们不应该在动物类中给出具体体现，而是应该给出一个声明即可。在Java中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类

抽象类特点
抽象类和抽象方法必须用abstract关键字修饰
格式
abstract class 类名 {}
public abstract void eat();
抽象类不一定有抽象方法 有抽象方法的类一定是抽象类
抽象类不能实例化
那么 抽象类如何实例化呢
按照多态的方式 由具体的子类实例化 其实这也是多态的一种 抽象类多态
抽象类的子类
要么是抽象类
要么重写抽象类中的所有抽象方法

1:在抽象的动物类中定义两个抽象方法。吃饭和睡觉。

抽象类的成员特点
成员变量 可以是变量   也可以是常量
构造方法 
有构造方法 但是不能实例化
那么 构造方法的作用是什么呢 用于子类访问父类数据的初始化
成员方法
可以有抽象方法 限定子类必须完成某些动作
也可以有非抽象方法 提高代码重用性

1:测试成员变量的时候，一定要定义两个，分别是变量，常量
  然后去访问，发现，变量是可以修改值的，而常量不能。
  由此可见，它里面的变量真的既可以是变量也可以是常量。
  并且，用类名调用一下，发现不可以，因为他们不是静态的。
2:可以有抽象方法，也可以有非抽象方法。分别定义两种类型的方法，然后测试。
最后提出一个问题：就是抽象类的非抽象方法有什么用?抽象方法有什么用?
抽象类的抽象方法：用于限定子类必须完成某些动作
抽象类的非抽象方法：用于提高代码的服用性

抽象类练习
猫狗案例
具体事物 猫 狗
共性 姓名 年龄 吃饭
老师案例
具体事物 基础班老师 就业班老师
共性 姓名 年龄 讲课
学生案例
具体事务 基础班学员 就业班学员
共性 姓名 年龄 班级 学习 吃饭
员工案例(备注部分)

假如我们在开发一个系统时需要对员工类进行设计，员工包含3个属性：姓名、工号以及工资。
经理也是员工，除了含有员工的属性外，另为还有一个奖金属性。
请使用继承的思想设计出员工类和经理类。要求类中提供必要的方法进行属性访问。

抽象类的几个小问题
一个类如果没有抽象方法 可不可以定义抽象类 如果可以 有什么意义
abstract不能和哪些关键字共存
private 冲突
final 冲突
static 无意义

接口概述
继续回到我们的猫狗案例，我们想想狗一般就是看门，猫一般就是作为宠物了，对不。但是，现在有很多的驯养员或者是驯兽师，可以训练出：猫钻火圈，狗跳高，狗做计算等。而这些额外的动作，并不是所有猫或者狗一开始就具备的，这应该属于经过特殊的培训训练出来的，对不。所以，这些额外的动作定义到动物类中就不合适，也不适合直接定义到猫或者狗中，因为只有部分猫狗具备这些功能。所以，为了体现事物功能的扩展性，Java中就提供了接口来定义这些额外功能，并不给出具体实现，将来哪些猫狗需要被培训，只需要这部分猫狗把这些额外功能实现即可

接口特点
接口用关键字interface表示 格式 interface 接口名 {}
类实现接口用implements表示 格式 class 类名 implements 接口名 {}
接口不能实例化
那么 接口如何实例化呢
按照多态的方式 由具体的子类实例化 其实这也是多态的一种 接口多态
接口的子类
要么是抽象类
要么重写接口中的所有抽象方法

1:在AnimalArain接口中定义两个功能：
	jump():跳高
	compute():计算

接口成员特点
成员变量
只能是常量
默认修饰符 public static final
构造方法 没有 因为接口主要是扩展功能的 而没有具体存在
成员方法 只能是抽象方法  默认修饰符 public abstract
1:演示的时候，要一点点的测试，先测试常量，再测试静态。

类与类 类与接口以及接口与接口的关系
类与类 继承关系 只能单继承 但是可以多层继承
类与接口 实现关系 可以单实现 也可以多实现 还可以在继承一个类的同时实现多个接口
接口与接口 继承关系 可以单元继承 也可以多继承

抽象类和接口的区别
成员区别
抽象类 变量 常量 有抽象方法 抽象方法 非抽象方法
接口 常量 抽象方法
关系区别
类与类 继承 单继承
类与接口 实现 单实现 多实现
接口与接口 继承 单继承 多继承
设计理念区别
抽象类 被继承体现的是 "is a"的关系 共性功能
接口 被实现体现的是 "like a"的关系 扩展功能

接口练习
猫狗案例 加入跳高的额外功能
老师和学生案例 加入抽烟的额外功能
教练和运动员案例(学生分析然后讲解)
乒乓球运动员和篮球运动员
乒乓球教练和篮球教练
为了出国交流 跟乒乓球相关的人员都需要学习英语
请用所学知识
分析 这个案例中有哪些抽象类 哪些接口 哪些具体类

1：写代码的时候，所有的东西都加上。(分析，实现，测试)
	动物类：姓名，年龄，吃饭，睡觉。
	动物培训接口：跳高
	猫继承动物类
	狗继承动物类
	部分猫继承猫类并实现跳高接口
	部分狗继承狗类并实现跳高接口

	通过抽象类测试基本功能。
	通过接口测试扩展功能。
	只测试猫，狗的测试留给学生自己练习	

2:写代码的时候，所有的东西都加上。(分析，实现，测试)
	人类：姓名，年龄，吃饭，睡觉。
	吸烟接口：吸烟
	老师继承人类
	学生继承人类
	部分老师继承人类并实现吸烟接口
	部分学生继承人类并实现吸烟接口

	通过抽象类测试基本功能。
	通过接口测试扩展功能。
	只测试老师，学生的测试留给学生自己练习

形式参数和返回值问题案例
形式参数
基本类型
引用类型
返回值类型
基本类型
引用类型
链式编程

1:形式参数的问题在前面匿名对象的时候已经讲解过了。
	但是，今天又多了抽象类和接口类型作为形式参数。

	形式参数
		类：需要的是该类的对象
		抽象类：需要的是该抽象类的子类对象
		接口：需要的是接口的子类对象

具体类作为形式参数：
class Student {
	public void show() {
		System.out.println(“show”);
	}
}

class StudentDemo {
	//如果参数是一个类名，那么实际需要的是一个具体的对象
	public void method(Student s) {
		s.show();
	}
} 

class StudentTest {
	public static void main(String[] args) {
		//如何调用StudentDemo中的method方法呢?
		StudentDemo sd = new StudentDemo();
		Student s = new Student();
		sd.method(s);
	}
}

抽象类作为形式参数：
abstract class Person {
	public abstract void show();
}

class PersonDemo {
	public void method(Person p) {
		p.show();
	}
}

//自己定义类继承自Person类

class PersonTest {
	public static void main(String[] args) {
		//如何调用PersonDemo中的method方法呢?
		PersonDemo pd = new PersonDemo ();
		Person p = new Student();
		pd.method(p);
	}

}

接口作为形式参数，类似抽象类作为形式参数。

2:返回值的问题
	基本类型 返回什么就用什么接收。
	引用类型 
		类：其实返回的是该类的对象
		抽象类：其实返回的是该类的子类对象
		接口：其实返回的是该接口的子类对象

具体类作为返回值类型：
class Student {
	public void show() {
		System.out.println(“show”);
	}
}

class StudentDemo {
	public Student getStudent() {
		//Student s = new Student();
		//return s;
		return new Student();
	}
} 

class StudentTest {
	public static void main(String[] args) {
		//如何测试呢？
		//原本我可以直接通过Student创建对象，调用功能
		//但是现在不让这样做，怎么办呢？
		StudentDemo sd = new StudentDemo();
		Student s = sd.getStudent();
		s.show();		
	}
}

抽象类作为返回值类型：
abstract class Person {
	public abstract void show();
}

class PersonDemo {
	public Person getPerson() {
		Person p = new ???();
		return p;
		
		return new ???();
	}
}

//自己定义类继承自Person类，否则PersonDemo代码无法完成？

class PersonTest {
	public static void main(String[] args) {
		//如何调用PersonDemo中的method方法呢?
		PersonDemo pd = new PersonDemo ();
		Person p = pd.getPerson();
		p.show(); //其实调用的是Student的
	}

}

接口作为返回值类型，类似抽象类作为返回值类型

3:链式编程的案例演示
	new PersonDemo().getPerson().show();

包
包的概述
其实就是文件夹
作用 对类进行分类管理
包的划分
举例
学生的增加 删除 修改 查询
老师的增加 删除 修改 查询
以及以后可能出现的其他的类的增加 删除 修改 查询
基本的划分 按照模块和功能分
高级的划分 就业班做项目的时候你就能看到了

包的定义及注意事项
定义包的格式
package 包名 多级包用.分开即可
注意事项
package语句必须是程序的第一条可执行的代码
package语句在一个java文件中只能有一个
如果没有package 默认表示无包名

带包的类的编译和运行
手动式
javac编译当前类文件 手动建立包对应的文件夹 把第一步骤的class文件放到第二步骤的最终文件夹下 通过java命令执行 注意了 需要带包名称的执行 java cn.itcast.Wel
自动式
javac编译的时候带上-d即可 javac -d Wel.java  通过java命令执行 和手动式一样

不同包下类之间的访问
定义两个类 Demo Test
Demo 求和方法(sum)
Test 测试方法(main)

1:首先演示成功
2:在说多次创建对象，发现比较麻烦，由此引出import关键字。

导包
导包概述
不同包下的类之间的访问 我们发现 每次使用不同包下的类的时候 都需要加包的全路径 比较麻烦 这个时候 java就提供了导包的功能
导包格式 import 包名;
注意
这种方式导入是到类的名称
虽然可以最后写* 但是不建议
package import class 有没有顺序关系(面试题)

权限修饰符         public protected 默认 private
同一类中           ~      ~         ~    ~
同一包子类 其他类  ~      ~         ~
不同包 子类        ~      ~
不同包 其他类      ~

类及其组成可以用的修饰符
类
默认 public final abstract
我们自己定义 public居多
成员变量
四种权限修饰符均可 final static
我们自己定义 private 居多
构造方法
四种权限修饰符均可 其他不可
我们自己定义 public 居多
成员方法
四种权限修饰符均可 final static abstract
我们自己定义 public 居多

内部类概述
把类定义在其他类的内部 这个类就被称为内部类
举例 在类A中定义了一个类B 类B就是内部类
内部类的访问特点
内部类可以直接访问外部类的成员 包括私有
外部类要访问内部类的成员 必须创建对象

1:用一个简单的案例演示代码，不做测试。


内部类位置
按照内部类在类中定义的位置不同 可以分为如下两种格式
成员位置(成员内部类)
局部位置(局部内部类)
成员内部类
外界如何创建对象
外部类名.内部类名 对象名 = 外部类对象.内部类对象;

1:首先说按照位置不同，划分为成员内部类和局部内部类。
2:然后先讲解成员内部类，并测试。

成员内部类
刚才我们讲解过了 成员内部类的使用 但是一般来说 在实际开发中是不会这样使用的 因为一般内部类就是不让外界直接访问的
举例讲解这个问题 Body和Heart 电脑和CPU
成员内部的常见修饰符
private 为了保证数据的安全性
static 为了让数据访问更方便
被静态修饰的成员内部类只能访问外部类的静态成员
内部类被静态修饰后的方法
静态方法
非静态方法

1:非静态的成员内部类，成员只能是非静态的。
2:内部类被静态修饰后的方法有静态和非静态之分。他们的访问和不用静态是不一样的。
访问非静态方法：外部类名.内部类名 对象名 = new 外部类名.内部类名();
访问静态方法：上面创建的对象访问，或者外部类名.内部类名.方法名();


成员内部类面面试题
补齐程序(注意:内部类和外部类没有继承关系)
	class Outer {
		public int num = 10;
		class Inner {
			public int num = 20;
			public void show() {
				int num = 30;
				System.out.println(?);
				System.out.println(??);
				System.out.println(???);
			}
		}
	}
在控制分别输出：30，20，10

class Outer {
	public int num = 10;
	
	class Inner {
		public int num = 20;
		
		public void show() {
			int num = 30;
			System.out.println(num);
			System.out.println(this.num);
			System.out.println(Outer.this.num);
		}
	}
}

class OuterDemo {
	public static void main(String[] args) {
		Outer.Inner oi = new Outer().new Inner();
		oi.show();
	} 
}


局部内部类
可以直接访问外部类的成员
可以创建内部类对象 通过对象调用内部类方法 来使用局部内部类功能
局部内部类访问局部变量的注意事项
必须被final修饰
为什么呢
因为局部变量会随着方法的调用完毕而消失 这个时候 局部对象并没有立骊从堆内存中消失 还要使用那个变量 为了让数据还能继续被调用 就用final修饰 这样 在堆内存里面存储的其实是一个常量值 通过反编译工具可以看一下

匿名内部类
就是内部类的简化写法
前提 存在一个类或者接口 这里的类可以是具体类也可以是抽象类
格式 new类名或者接口名(){重写方法;}
本质 是一个继承了类或者实现了接口的子类匿名对象

1:通过new去分析，结果是一个对象。
2:如果类是抽象类，或者new后面是接口，所以整体应该是子类对象。
3:又由于没有名字，所以，整体是一个匿名对象。

匿名内部类案例
写案例 并测试
如何调用方法
加入方法有多个 如何调用呢
方式1 每一种格式调用一个 太麻烦
方式2 用类或者接口接收该子类对象 多态思想

匿名内部类在开发中的使用
首先回顾我们曾经讲过的方法的形式参数是引用类型的情况 重点是接口的情况 我们知道这里需要一个子类对象 而匿名内部类就是一个子类匿名对象 所以 可以使用匿名内部类改时以前的做法

abstract class Person {
	public abstract void show();
}

class PersonDemo {
	public void method(Person p) {
		s.show();
	}
}

class PersonTest {
	public static void main(String[] args) {
		//如何调用PersonDemo中的method方法呢?
		PersonDemo pd = new PersonDemo ();
		pd.method(new Person() {
			public void show() {
				System.out.println(“show”);
			}
		});
	}
}

匿名内部类面试题
按照要求 补齐代码
interface Inter {void show();}
class Outer{//补齐代码}
class OuterDemo{
	public static void main(String[] args){
	    Outer.method().show();
	}
}
要求在控制台输出 "welcome to java world"